Um relat√≥rio final do projeto deve ser apresentado. 
O trabalho deve conter:
 Explica√ß√£o teorica do funcionamento dos algoritmos de detec√ßao e corre√ßao de erros utilizados;
 Compara√ßao entre os resultados obtidos utilizando os algoritmos: CRC-8, Hamming, MD5 e SHA1 sob os cenarios: 
flipar bits pares, 
flipar bits impares, 
flipar de forma aleatoria de 1 a x% os bits do payload da mensagem, 
nao flipar nenhum bit;
  -taxa de erro detectados;
 Apresentar conclusao mostrando quais vantagens e desvantagens de cada algoritmo e qual seria o melhor algoritmo em um determinado contexto;
	                    |CRC-8	|Hamming	|MD5	 |SHA1
-----------------------------------------------------------------	                    
Flipar bits pares	    |	      |         |      |
-----------------------------------------------------------------	 
Flipar bits impares		|		    |         |      |
-----------------------------------------------------------------	 
Flipar bits aleat√≥rios|				|         |      |
-----------------------------------------------------------------	 
N√£o flipar bits				|       |         |      |

Hamming
C√≥digos de Hamming s√£o usados para inserir informa√ß√µes de corre√ß√£o de erros em fluxos de dados. Os c√≥digos s√£o concebidos de modo que um erro n√£o s√≥ √© detectado, mas tamb√©m corrigido. Adicionar informa√ß√µes de corre√ß√£o de erros aumenta a quantidade de dados, mas aumenta tamb√©m a confiabilidade das comunica√ß√µes sobre os meios com altas taxas de erro. A codifica√ß√£o de Hamming pode ser complicada de implementar, mas pode ser feita muito rapidamente usando truques aritm√©ticos em n√≠vel de bits. Isto permite a cria√ß√£o de um sistema de corre√ß√£o de erros √∫til e de alta velocidade, para ser utilizado em aplica√ß√µes embarcadas.
Instru√ß√µes
Crie a palavra de dados. Qualquer bit com uma posi√ß√£o que for uma pot√™ncia de dois (primeiro, segundo, quarto, etc.) deve ser reservado para informa√ß√µes de paridade. Use o tamanho que for necess√°rio para que a palavra tenha os dados originais e os bits de paridade. Exemplo: 1 1 0 1 0 0 1 0 transforma-se em _ _ 1 _ 1 0 1 _ 0 0 1 0 Os bits originais permanecem na mesma ordem, mas foram espalhados para inserirmos os bits de paridade.
Calcule o primeiro bit de paridade. Come√ßando com o primeiro bit, l√™-se um bit e, em seguida, pula-se um bit e repete-se o procedimento at√© o final. Enquanto isso conta-se o n√∫mero de uns encontrados. Os bits de paridade n√£o contam neste processo. Se o n√∫mero de uns for par, defina o primeiro bit como zero. Caso contr√°rio, defina-o para um. Exemplo: Bits 1, 3, 5, 7, 9 e 11 de _ _ 1 _ 1 0 1 _ 0 0 1 0, _11101, cont√™m quatro uns. Este √© par, ent√£o, o primeiro bit √© definido como zero: 0 _ 1 _ 1 0 1 _ 0 0 1 0
Calcule os bits de paridade restantes. Come√ßando com o segundo bit, l√™-se dois bits e, em seguida, pula-se dois bits e repete-se o procedimento at√© o final. O quarto bit l√™ quatro bits, pula outros quatro, come√ßando pelo bit quatro. O mesmo padr√£o √© seguido por todos os bits de paridade, at√© todos serem computados. Exemplo: Bit 2: 0 _ 1 _ 1 0 1 _ 0 0 1 0 verifica _1, 01, 01, que cont√™m tr√™s uns, ent√£o o bit 2 √© definido como um. Bit 4: _ 0 1 1 1 0 1 _ 0 0 1 0 verifica _101, 0, que cont√™m dois uns, ent√£o o bit 4 √© definido como zero. Bit 8: 0 1 1 0 1 0 1 _ 0 0 1 0 verifica _0010, que cont√™m s√≥ um, ent√£o o bit 8 √© definido como um. A palavra √©, portanto, codificada como 011010110010.
Confirme a palavra. Se uma palavra estiver corrompida, os bits de paridade n√£o v√£o coincidir com o que √© esperado. Para confirmar que a palavra n√£o esteja corrompida, basta calcular os bits de paridade usando as etapas dois e tr√™s. Se os bits n√£o forem iguais, grave suas posi√ß√µes.
Corrija o bit errado. Se voc√™ encontrar bits de paridade incorretos, simplesmente some as posi√ß√µes dos bits. O valor da soma √© a posi√ß√£o do bit incorreto. Troque o valor do bit nesta posi√ß√£o. Por exemplo, se os bits de paridade incorretos forem o um e o quatro, trocar o valor do quinto bit corrigir√° o erro.

CRC-8
O controlo de redund√¢ncia c√≠clico (notado CRC, ou em ingl√™s Cyclic Redundancy Check) √© um meio de controlo de integridade dos dados potente e f√°cil de aplicar. Representa o principal m√©todo de detec√ß√£o de erros utilizado nas telecomunica√ß√µes.
Princ√≠pio
O controlo de redund√¢ncia c√≠clico consiste em proteger blocos de dados, chamados tramas (frames em ingl√™s). A cada trama √© associado um bloco de dados, chamado c√≥digo de controlo (√†s vezes CRC por abuso de linguagem ou FCS para Frame Check Sequ√™ncia no caso de um c√≥digo de 32 bits). O c√≥digo CRC cont√©m elementos redundantes no que diz respeito √† trama, permitindo detectar os erros, mas tamb√©m repar√°-los. 
O princ√≠pio do CRC consiste em tratar as sequ√™ncias bin√°rias como polin√≥mios bin√°rios, quer dizer polin√≥mios cujos coeficientes correspondem √† sequ√™ncia bin√°ria. Assim, a sequ√™ncia bin√°ria 0110101001 pode ser representada sob a forma polinomial seguinte: 
0*X9 + 1*X8 + 1*X7 + 0*X6 + 1*X5 + 0*X4 + 1*X3 + 0*X2 + 0*X1 + 1*X0 soit  X8 + X7 + X5 + X3 + X0 ou encore  X8 + X7 + X5 + X3 + 1
Desta maneira, o bit de peso fraco da sequ√™ncia (o bit mais √† direita) representa o grau 0 polin√≥mio (X0 = 1), o 4¬∫ bit partindo da direita representa o grau 3 polin√≥mio (X3)‚Ä¶ Uma sequ√™ncia de n bits constitui por conseguinte um polin√≥mio de grau m√°ximo n-1. Todas as express√µes polinomiais s√£o manipuladas seguidamente com uma aritm√©tica m√≥dulo 2. 
Neste mecanismo de detec√ß√£o de erro, um polin√¥mio predefinido (chamado polin√¥mio gerador e notado G (X)) √© conhecido do emissor e o receptor. A detec√ß√£o de erro consiste, para o emissor, em efetuar um algoritmo sobre os bits da trama a fim de gerar um CRC, e transmitir estes dois elementos ao receptor. Basta ent√£o ao receptor que efetue o mesmo c√°lculo a fim de verificar que o CRC √© v√°lido.

MD5
O MD5 foi desenvolvido por Ron Rivest em 1991. √â basicamente o MD4 com um "cinto de seguran√ßa" - os c√°lculos s√£o um pouco mais lentos, mas, em compensa√ß√£o, √© muito mais seguro.
Da mesma forma que outras fun√ß√µes hash, o MD5 √© usado em assinaturas digitais onde um texto longo precisa ser "comprimido" de forma segura antes de ser cifrado com uma chave privada (secreta) por um criptossistema de chave p√∫blica. Foi projetado para m√°quinas de 32 bits, podendo ser facilmente programado de forma compacta. O autor colocou o algoritmo no dom√≠nio p√∫blico em abril de 1992.
Como o texto sobre a fun√ß√£o hash MD4 √© bastante minucioso e o MD5 √© muito parecido, n√£o h√° a necessidade de entrar em muitos detalhes. Caso voc√™ tenha d√∫vidas, complemente a leitura com o texto MD4.
Descri√ß√£o do algoritmo MD5
A entrada do MD5 √© um fluxo de dados (mensagem) que pode ter um n√∫mero arbitr√°rio de bits, representado por b, um n√∫mero inteiro positivo que varia de zero at√© o infinito. Para obter o digesto da mensagem, seus bits, representados por m0, m1, ..., m{b-1}, onde b = n√∫mero de bits da mensagem, s√£o submetidos a diversas opera√ß√µes. Este processo √© dividido em cinco etapas ou passos.
Passo 1: Prepara√ß√£o do fluxo de dados
Adiciona-se √† mensagem os bits necess√°rios para que seu tamanho mais 64 bits seja divis√≠vel por 512.
Passo 2: Inclus√£o do comprimento
Depois da adi√ß√£o de bits, uma representa√ß√£o bin√°ria do tamanho original da mensagem e que ocupa 64 bits, √© adicionada √† mesma. O conjunto obtido √© processado em blocos de 512 bits na estrutura iterativa de Damg√•rd/Merkle, sendo que cada bloco √© processado em quatro rodadas distintas.
Passo 3: Inicializa√ß√£o do buffer MD
Um buffer de quatro words √© usado para calcular o digesto da mensagem. Os registradores de 32 bits A, B, C e D s√£o inicializados com os seguintes valores hexadecimais:
     word A: 01 23 45 67
     word B: 89 ab cd ef
     word C: fe dc ba 98
     word D: 76 54 32 10
Passo 4: Processamento da mensagem em blocos de 16 words (512 bits)
Primeiro definse-se quatro fun√ß√µes auxiliares. Cada uma delas usa tr√™s words de 32 bits para produzir uma sa√≠da de um word de 32 bits.
     F(X,Y,Z) = (X and Y) or (not(X) and Z)
     G(X,Y,Z) = (X and Z) or (Y and not(Z))
     H(X,Y,Z) = X xor Y xor Z
     I(X,Y,Z) = Y xor (X or not(Z))
A fun√ß√£o F atua como condicional sobre cada um dos bits: se X ent√£o Y sen√£o Z. √â importante frisar que, se os bits de X, Y e Z s√£o independentes e n√£o induzidos (unbiased) ent√£o cada bit de F(X,Y,Z) tamb√©m ser√° independente e n√£o induzido.
As fun√ß√µes G, H e I s√£o semelhantes √† fun√ß√£o F quanto √† a√ß√£o "paralela bit a bit" produzindo sa√≠das de bits independentes e n√£o induzidos se os mesmos tiverem estas caracter√≠sticas. A fun√ß√£o H √© apenas um "XOR" ou fun√ß√£o de "paridade" das suas entradas.
As etapas deste passo usam uma tabela de 64 elementos, T[1] a T[64], constru√≠da √† partir da fun√ß√£o seno. T[i] for o n√©simo elemento da tabela e √© igual √† parte inteira de abs(seno(i)) multiplicada por 4294967296, onde i √© expresso em radianos.

Antes de iniciar o processamento, deve-se armazenar os valores de A, B, C e D. Neste texto, as vari√°veis de trabalho ser√£o expressas em letras min√∫sculas, portanto armazenamos a = A, b = B, c = C e d = D.
Divide-se cada bloco de 512 bits em 16 sub-blocos de 32 bits, aqui identificados por X[0] a X[15]. Genericamente, os sub-blocos s√£o designados por X[k]. A seguir, aplica-se as fun√ß√µes F, G, H e I em quatro rodadas:
     /* Rodada 1
     /* Seja [abcd k s i] a opera√ß√£o a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
     /* Fa√ßa as seguintes 16 opera√ß√µes.
     [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
     [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
     [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
     [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
     /* Rodada 2
     /* Seja [abcd k s i] a opera√ß√£o a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
     /* Fa√ßa as seguintes 16 opera√ß√µes.
     [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
     [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
     [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
     [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]
     /* Rodada 3
     /* Seja [abcd k s i] a opera√ß√£o a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
     /* Fa√ßa as seguintes 16 opera√ß√µes
     [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
     [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
     [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
     [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]
     /* Rodada 4
     /* Seja [abcd k s i] a opera√ß√£o a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
     /* Fa√ßa as seguintes 16 opera√ß√µes
     [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
     [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
     [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
     [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]
     /* Finalmente, fa√ßa as adi√ß√µes dos resultados obtidos para a, b, c, d
     /* com os valores iniciais de A, B, C e D
     A = a + A
     B = b + B
     C = c + C
     D = d + D
Passo 5: A sa√≠da
O digesto da mensagem produzido na sa√≠da √© a concatena√ß√£o de A, B, C e D. Come√ßa-se com o byte menos significativo de A e termina-se com o byte mais significativo de D.

SHA1
A fam√≠lia de SHA (Secure Hash Algorithm) est√° relacionada com as fun√ß√µes criptogr√°ficas. A fun√ß√£o mais usada nesta fam√≠lia, a SHA-1, √© usada numa grande variedade de aplica√ß√µes e protocolos de seguran√ßa, incluindo TLS, SSL, PGP, SSH, S/MIME e IPSec. SHA-1 foi considerado o sucessor do MD5. Ambos t√™m vulnerabilidades comprovadas1 . Em algumas correntes, √© sugerido que o SHA-256 ou superior seja usado para tecnologia cr√≠tica. Os algoritmos SHA foram projetados pela National Security Agency (NSA) e publicados como um padr√£o do governo Norte-Americano.
O primeiro membro da fam√≠lia, publicado em 1993, foi oficialmente chamado SHA; no entanto, √© frequentemente chamado SHA-0 para evitar confus√µes com os seus sucessores. Dois anos mais tarde, SHA-1, o primeiro sucessor do SHA, foi publicado. Desde ent√£o quatro variantes foram lan√ßadas com capacidades de sa√≠da aumentadas e um design ligeiramente diferente: SHA-224, SHA-256, SHA-384, e SHA-512 ‚Äî por vezes chamadas de SHA-2.
Foram feitos ataques a ambos SHA-0 e SHA-12 . Ainda n√£o foram reportados ataques √†s variantes SHA-2, mas como elas s√£o semelhantes ao SHA-1, pesquisadores est√£o preocupados, e est√£o a desenvolver candidatos para um novo e melhor padr√£o de hashing.

Observa√ß√µes:
O cliente destino receber√° do socket estabelecido com o servidor a mensagem encaminhada pelo cliente origem. O cabe√ßalho da mensagem fornecer√° a informa√ß√£o de qual algoritmo de corre√ß√£o foi aplicado. O cliente destino dever√° verificar se a mensagem foi recebida de maneira correta. Caso contr√°rio, dever√° tentar recuperar a informa√ß√£o original.
=>Os algoritmos de detec√ß√£o de erros MD5 e SHA1 n√£o permitem que a mensagem original seja recuperada pela natureza da fun√ß√£o hash utilizada na implementa√ß√£o das mesmas.
Compara√ß√£ao entre os resultados obtidos utilizando os algoritmos: CRC-8, Hamming, MD5 e SHA1 sob os cen√°rios: flipar bits pares, flipar bits √≠mpares, flipar de forma aleat√≥ria de 1 a x% os bits do payload da mensagem, n√£o flipar nenhum bit;
=>O algoritmo de detec√ß√£o de erro,Hamming,n√£o corrige mais de 1 bit em seua execu√ß√£o.
